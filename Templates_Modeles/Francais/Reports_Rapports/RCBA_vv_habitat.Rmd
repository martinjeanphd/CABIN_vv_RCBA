---
title: "Vérification et validation RCBA - données d'habitat"
date: '2017-11-01'
output:
  html_notebook:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_float: yes
  html_document:
    df_print: paged
    toc: yes
  word_document:
    toc: yes
version: '1.1'
---

| ![](../../../Configuration/gc_fr.png)  |  ![](../../../Configuration/rcba_logo.png) |
|:------------------------------------|--------------------------------------:|                            


# VÉRIFICATION ET VALIDATION RCBA - DONNÉES D'HABITAT

*Environnement et changement climatique Canada*

*Analyse réalisée le `r Sys.time()`*

***

Ce document est un carnet de note écrit en [Markdown R](http://rmarkdown.rstudio.com). Lorsque vous éxécuter le code intégré au carnet, les résulats apparaitront sous le code correspondant.

Ce rapport présente les résultats de la vérification et la validation des données d'habitat pour le projet **`r paste(analysisTitle)`**.

Dans cette analyse, le jeu de descripteurs d'habitat sera vérifié pour répondre à la question suivante :
  
  + Les données d'habitat correspondent-elles bien à ce qui a été observé sur le terrain ?

Ce document est un carnet de notes [R Markdown](http://rmarkdown.rstudio.com). Pour obtenir les résultats de la vérification et la validation des données, exécutez les commandes contenues dans ce carnet de notes. Pour ce faire, positionnez votre curseur à l'intérieur d'une boîte de commandes et cliquez sur la flèche verte à la droite de celle-ci nommée *Run Current Chunk* ou appuyez sur les touches *Ctrl+Maj+Entrée* (*Cmd-Maj+Entrée* sur *macOS*) de votre clavier. Répétez pour chaque boîte de commandes. À mesure que les commandes contenues dans ce carnet seront exécutées, les résultats apparaîtront sous chacune des commandes correspondantes dans la présente fenêtre. Une fois toutes les commandes exécutées, cliquez sur le bouton *Preview* en haut à gauche de la présente fenêtre ou appuyer sur les touches *Ctrl+Maj+K*. Une nouvelle fenêtre apparaîtra et contiendra le rapport de ces résultats de la vérification et la validation des données générales RCBA.

## Prérequis

```{r setup, include=FALSE}
## Required Packages and Custom Functions
source("../../../Required_packages.R")
source("../../../Required_functions.R")


## Project Preferences
source("../../../Configuration/project_settings.R")

```

Ce carnet suppose que vous avez importé vos données dans *R* en utilisant le carnet d'importation de données (AED_Importation.Rmd).

Le fichier contenant les donneés d'habitat de ce projet est **`r if(is.data.frame(dataset.ENV)) "présent" else "absent. Veuillez ouvrir et exécuter le carnet 'RCBA_vv_importation.Rmd' avant d'exécuter le présent carnet"`**.

## Statistiques descriptives

Le fichier de données contient `r nrow(dataset.ENV) ` visites (lignes) et `r ncol(dataset.ENV) ` taxons (colonnes).

Le tableau suivant présente une partie des données du fichier.

**Lecture des données d'habitat**

`r datatable(dataset.ENV, filter = "top", rownames=F, options = list(scrollX = TRUE )) `

> ![ACTION:](../../../Configuration/action.png)
> *Vérifiez les données et assurez-vous que cela réflète bien la réalité. Examinez particulièrement les éléments suivants:*
>
> - *Le fichier semble-t'il avoir été lu correctement?*
> - *Des colonnes sont-elles manquantes?*

**Liste des visites présentes dans les données d'habitat (ID provenant de la base de données RCBA) :**  

`r rownames(dataset.ENV) `

> ![ACTION:](../../../Configuration/action.png)
> *Vérifiez les données et assurez-vous que cela réflète bien la réalité. Comparez la liste ci-haut avec le tableau suivant qui présente les visites présentes dans l'un ou l'autre des fichiers de données pour vous assurez que tout est adéquat.


`r datatable(dataset.NAM, filter = "top", rownames=F, options = list(scrollX = TRUE ))`

**Liste des variables :**  

`r colnames(dataset.ENV) `

> ![ACTION:](../../../Configuration/action.png)
> *Vérifiez les variables ci-haut et assurez-vous qu'elles sont toutes présentes.


### Statistiques générales

Le tableau suivant présente les statistiques générales par variable. Lorsque le résultat obtenu à la ligne *BinaryData* du tableau est *TRUE*, cela indique que la variable présente des données binaires. Cependant, ce résultat peut également n'être obtenu que parce que la variable ne présente qu'une à deux données au maximum. La ligne *Na.values* indique le nombre de valeurs manquantes que présente chaque variable.

**Tableau des statistiques générales**

```{r, echo=FALSE}

#Tableau des paramètres généraux par variable

{summary.ENV <- suppressWarnings(as.data.frame(t(do.call(cbind, lapply(dataset.ENV, summary)))))
summary.ENV$Std.deviation <- apply(dataset.ENV, 2, sd, na.rm = T)
summary.ENV$Length <- colSums(!is.na(dataset.ENV))
summary.ENV$BinaryData <- sapply(dataset.ENV,function(x)length(unique(na.omit(x)))<=2)
summary.ENV$NA.values <- colSums(is.na(dataset.ENV))
summary.ENV$`NA's` <- NULL
summary.ENV <- as.data.frame(t(summary.ENV))
#summary.ENV
}
datatable(summary.ENV[which(Var_Type[match(colnames(summary.ENV), Var_Type[,1]),2]=="Numeric")], filter = "top", rownames=T, options = list(scrollX = TRUE ))
datatable(summary.ENV[which(Var_Type[match(colnames(summary.ENV), Var_Type[,1]),2]=="Binary")], filter = "top", rownames=T, options = list(scrollX = TRUE ))
datatable(summary.ENV[which(Var_Type[match(colnames(summary.ENV), Var_Type[,1]),2]!="Numeric" & Var_Type[match(colnames(summary.ENV), Var_Type[,1]),2]!="Binary")], filter = "top", rownames=T, options = list(scrollX = TRUE ))

```

> ![ACTION:](../../../Configuration/action.png)
> *Vérifiez les données et assurez-vous qu'elles réflètent bien la réalité. Examinez les statistiques de base et identifiez, le cas échéant, des anomalies au niveaux des statistiques de base.

## Localisation des données environnementales

### Distribution géographique des variables d'habitat

Les graphiques suivants illustrent la position (latitude et longitude) ainsi que la valeur observée des variables dans le fichier de données d'habitat.

```{r, echo=FALSE, warning=FALSE}
#Distribution géographique des valeurs des variables d'habitat

dataset.GEN2 <- dataset.GEN
dataset.ENV2 <- left_join(dataset.ENV2, dataset.GEN2[,c("SampleId", "Longitude", "Latitude")], by = "SampleId")

Numeric_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude))[which(Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]=="Numeric")]

for(i in 1:ncol(Numeric_ENV2)){
graph.geo.ab <- ggplot(dataset.ENV2, aes(Longitude, Latitude)) +
  geom_point(shape = 21, aes(size = (Numeric_ENV2[,i]))) + 
  ggtitle(paste("Distribution géographique de la variable\n", colnames(Numeric_ENV2[i]))) +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_size(range = c(1,10), name = "Valeur")
graph.geo.ab
print(graph.geo.ab)
}

rm(Numeric_ENV2)

```


Données binaires

```{r}
Binary_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude))[which(Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]=="Binary")]

for(i in 1:ncol(Binary_ENV2)){
graph.geo.ab <- ggplot(dataset.ENV2, aes(Longitude, Latitude)) +
  geom_point(shape = 21, aes(size = (Binary_ENV2[,i]))) + 
  ggtitle(paste("Distribution géographique de la variable\n", colnames(Binary_ENV2[i]))) +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_size(range = c(1,10), name = "Valeur")
graph.geo.ab
print(graph.geo.ab)
}

rm(Binary_ENV2)
```

Autres données

```{r}
Other_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude, -SampleId))[which(Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude, -SampleId)), Var_Type[,1]),2]!="Numeric" & Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude, -SampleId)), Var_Type[,1]),2]!="Binary")]

for(i in 1:ncol(Other_ENV2)){
graph.geo.ab <- ggplot(dataset.ENV2, aes(Longitude, Latitude)) +
  geom_point(shape = 21, aes(size = (Other_ENV2[,i]))) + 
  ggtitle(paste("Distribution géographique de la variable\n", colnames(Other_ENV2[i]))) +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_size(range = c(1,10), name = "Valeur")
graph.geo.ab
print(graph.geo.ab)

}
rm(Other_ENV2)

```

### Cartographie de la distribution de l'altitude par site

La carte interactive suivante illustre la position des sites en fonction des coordonnées géographiques contenues dans le fichier de données ainsi que l'altitude par site. Cliquez sur le marqueur d'une visite pour indiquer l'altitude observée dans celle-ci.

```{r, echo=FALSE, fig.height=5.5, fig.width=8.5, message=FALSE, include=TRUE}
#Cartographie de la distribution de l'altitude par site

dataset.SPA2 <- dataset.SPA
dataset.NAM2 <- dataset.NAM
dataset.SPA2 <- left_join(dataset.SPA2, dataset.NAM2[, c("SampleId", "Site", "SampleDate")], by = "SampleId")
dataset.SPA2$Site_Date_Number <- paste(dataset.SPA2$Site, "_", dataset.SPA2$SampleDate, "_", dataset.SPA2$SampleId)
dates <- as.Date(dataset.SPA2$SampleDate, "%Y-%m-%d")
dataset.SPA2$Year <- strftime(parse_date_time(as.character(dates), "%Y-%m-%d"), "%y")
dataset.SPA2$Site_Year <- paste(dataset.SPA2$Site, "_", dataset.SPA2$Year)

cabinPoints <- SpatialPointsDataFrame(coords = dataset.SPA[which(!is.na(dataset.SPA[, 1]) & !is.na(dataset.SPA[,2])),1:2], data = dataset.SPA[which(!is.na(dataset.SPA[, 1]) & !is.na(dataset.SPA[,2])),])

leaflet(data = dataset.SPA2) %>% addProviderTiles(providers$Esri.WorldTopoMap) %>% addCircleMarkers(~Longitude, ~Latitude, popup = paste( "Site_Year : ", dataset.SPA2$Site_Year, "<br>", "Altitude : ", dataset.ENV2$Altitude, "<br>"), label = (dataset.SPA2$Site_Year), color = getColor2(dataset.SPA2), stroke = F, fillOpacity = 0.5, clusterOptions = markerClusterOptions()) %>% addLegend(
  position = 'bottomright',
  colors = c("green", "yellow", "darkorange", "red", "pink", "blue", "darkgreen", "cyan", "deeppink", "lightblue", "lightseagreen", "darkviolet", "darkred", "cadetblue", "black", "gray", "white", "brown"),
  labels = c("Pre-2006", "2006", "2007", "2008", "2009", "2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018", "2019", "2020", "2021", "Other"),
  opacity = 1,
  title = 'Légende')
  
rm(dataset.SPA2)

```


## Présence de données aberrantes

### Dispersion des valeurs observées

Les diagrammes de dispersion suivants présentent la valeur des données de variables continues observées dans le fichier de données dans l'ordre à laquelle elles apparaissent dans ce fichier pour chaque variable. Sous l'axe des X se trouve l'identifiant de la visite vis-à-vis la valeur observée correspondante, soit le nom du site d'où provient la donnée, sa date d'échantillonnage et le nombre d'échantillonnage pris pour cette donnée.

> ![ACTION:](../../../Configuration/action.png)
> *Vérifier les données et assurez-vous qu'elles réflètent bien la réalité. Examinez les points suivants :*
>
> - *Des données sortent-elles de l'ordinaire?*


```{r, echo=FALSE, warning=FALSE}
#Diagrammes de dispersion des valeurs observées par variable numériques d'habitat

dataset.NAM2$Site_Date_Number <- paste(dataset.NAM2$Site, "_", dataset.NAM2$SampleDate, "_", dataset.NAM2$SampleId)
dataset.ENV2 <- left_join(dataset.ENV2, dataset.NAM2[,c("SampleId", "Site_Date_Number")], by = "SampleId")

Numeric_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude))[,which(Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]=="Numeric" | colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)) %in% c("SampleId", "Site_Date_Number"))]

for(j in 2:(ncol(Numeric_ENV2 %>% dplyr::select(-Site_Date_Number)))){
plot.ab <- ggplot(Numeric_ENV2, aes(x = Numeric_ENV2$Site_Date_Number, y = Numeric_ENV2[,j])) +
  geom_point() +
  labs(y = "Valeur", x = "Visite") +
  theme(axis.text.x = element_text(angle = 90, vjust = -0.05)) +
   scale_x_discrete(breaks = ifelse(!is.na(Numeric_ENV2[,j]), Numeric_ENV2$Site_Date_Number, ""), labels = ifelse(!is.na(Numeric_ENV2[,j]), Numeric_ENV2$Site_Date_Number, ""), na.value = NA) +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("Valeurs observées de\n", colnames(Numeric_ENV2[j])))
plot.ab
print(plot.ab)}

```

```{r, echo=FALSE, warning=FALSE}
#Diagrammes de dispersion des valeurs observées par variable binaires d'habitat

Binary_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude))[,which(Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]=="Binary" | colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)) %in% c("SampleId", "Site_Date_Number"))]

for(j in 2:(ncol(Binary_ENV2 %>% dplyr::select(-Site_Date_Number)))){
plot.ab <- ggplot(Binary_ENV2, aes(x = Binary_ENV2$Site_Date_Number, y = Binary_ENV2[,j])) +
  geom_point() +
  labs(y = "Valeur", x = "Visite") +
  theme(axis.text.x = element_text(angle = 90, vjust = -0.05)) +
   scale_x_discrete(breaks = ifelse(!is.na(Binary_ENV2[,j]), Binary_ENV2$Site_Date_Number, ""), labels = ifelse(!is.na(Binary_ENV2[,j]), Binary_ENV2$Site_Date_Number, ""), na.value = NA) +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("Valeurs observées de\n", colnames(Binary_ENV2[j])))
plot.ab
print(plot.ab)}
```


```{r, echo=FALSE, warning=FALSE}
#Diagrammes de dispersion des valeurs observées pour les autres variables d'habitat

Other_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude))[,which((Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]!="Numeric" & Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]!="Binary") | colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)) %in% c("SampleId", "Site_Date_Number"))]

for(j in 2:(ncol(Other_ENV2 %>% dplyr::select(-Site_Date_Number)))){
plot.ab <- ggplot(Other_ENV2, aes(x = Other_ENV2$Site_Date_Number, y = Other_ENV2[,j])) +
  geom_point() +
  labs(y = "Valeur", x = "Visite") +
  theme(axis.text.x = element_text(angle = 90, vjust = -0.05)) +
   scale_x_discrete(breaks = ifelse(!is.na(Other_ENV2[,j]), Other_ENV2$Site_Date_Number, ""), labels = ifelse(!is.na(Other_ENV2[,j]), Other_ENV2$Site_Date_Number, ""), na.value = NA) +
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("Valerus observées de\n", colnames(Other_ENV2[j])))
plot.ab
print(plot.ab)}
```

### Boîtes à moustaches des valeurs observées et transformées

La première boîte à moustaches (à gauche) présentent la distribution des valeurs de variables continues observées dans le fichier de données et la deuxième boîte à moustaches (à droite) présentent la distribution des valeurs de variables continues observées ayant subies une transformation logarithmique. 

> ![ACTION:](../../../Configuration/action.png)
> *Vérifiez les données et assurez-vous que cela réflète bien la réalité. Examinez particulièrement les éléments suivants:*
>
> - *Des données semblent-elles sortir de l'ordinaire?*

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#Boîtes à moustaches des valeurs observées et transformées - variables numériques

for(i in 2:(ncol(Numeric_ENV2 %>% dplyr::select(-Site_Date_Number)))){
box.ab.1 <- qplot(y = Numeric_ENV2[,i], x = "", geom = "boxplot", ylab = colnames(Numeric_ENV2[i])) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste(colnames(Numeric_ENV2[i]), "\n (raw data)"))
box.ab.2 <- qplot(y = Numeric_ENV2[,i], x = "", geom = "boxplot", ylab = paste("Log(", colnames(Numeric_ENV2[i]),")"), log = "y") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste(colnames(Numeric_ENV2[i]), "\n(données transformées au log)"))

grid.arrange(box.ab.1, box.ab.2, ncol = 2, top = colnames(Numeric_ENV2[i]))
}

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#Boîtes à moustaches des valeurs observées et transformées - variables binaires

for(i in 2:(ncol(Binary_ENV2 %>% dplyr::select(-Site_Date_Number)))){
box.ab.1 <- qplot(y = Binary_ENV2[,i], x = "", geom = "boxplot", ylab = colnames(Binary_ENV2[i])) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste(colnames(Binary_ENV2[i]), "\n (raw data)"))
box.ab.2 <- qplot(y = Binary_ENV2[,i], x = "", geom = "boxplot", ylab = paste("Log(", colnames(Binary_ENV2[i]),")"), log = "y") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste(colnames(Binary_ENV2[i]), "\n(données transformées au log)"))

grid.arrange(box.ab.1, box.ab.2, ncol = 2, top = colnames(Binary_ENV2[i]))
}

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#Boîtes à moustaches des valeurs observées et transformées - autres variables

for(i in 2:(ncol(Other_ENV2 %>% dplyr::select(-Site_Date_Number)))){
box.ab.1 <- qplot(y = Other_ENV2[,i], x = "", geom = "boxplot", ylab = colnames(Other_ENV2[i])) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste(colnames(Other_ENV2[i]), "\n (raw data)"))
box.ab.2 <- qplot(y = Other_ENV2[,i], x = "", geom = "boxplot", ylab = paste("Log(", colnames(Other_ENV2[i]),")"), log = "y") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste(colnames(Other_ENV2[i]), "\n(données transformées au log)"))

grid.arrange(box.ab.1, box.ab.2, ncol = 2, top = colnames(Other_ENV2[i]))
}

```

### Identification des données aberrantes potentielles

La première boîte à moustaches (à gauche) présentent la distribution des valeurs de variables continues observées dans le fichier de données et le diagramme de dispersion (à droite) présentent la distribution des valeurs de variables continues observées dans l'ordre à laquelle elles apparaissent dans ce fichier. Les données présentant une identification par leur identifiant sur les diagrammes représentent les données potentiellement aberrantes contenues dans le fichier de données. La méthode utilisée pour identifier les données potentiellement aberrantes est l'étendue interquantile (*Interquantile range* ou *IQR*). L'IQR se calcule de la manière suivante :

`IQR(x) = quantile(x, 3/4) - quantile(x, 1/4)`


Les valeurs potentiellement aberrantes sont définies comme des observations qui se situent au-dessous de *Q1 - 1,5 IQR* ou plus de *Q3 + 1,5 IQR*.

L'identifiant de la visite correspond au nom du site d'où provient la donnée, sa date d'échantillonnage et le nombre d'échantillonnage pris pour cette donnée.

> ![ACTION:](../../../Configuration/action.png)
> *Examinez les graphiques suivants et portez votre attention sur les points (si présents) auxquels un identifiant est associé. Posez-vous la question suivante :*
>
> - *Les données potentiellement aberrantes le sont-elles vraiment?*


```{r, echo=FALSE, warning=FALSE}
#Identification des données aberrantes potentielles - données numériques

for (j in 2:(ncol(Numeric_ENV2)-2)) {
  boxplot <- ggplot(data = Numeric_ENV2, aes(x = "", y = Numeric_ENV2[,j])) +
    geom_boxplot() +
    ylab("Valeur") +
    xlab("") +
    theme(plot.title = element_text(hjust = 0.5)) +
    ggtitle(paste("Valeurs observées de\n", colnames(Numeric_ENV2[j]))) +
    geom_text(aes(label = ifelse(Numeric_ENV2[,j] < quantile(Numeric_ENV2[,j], probs=c(.25), na.rm = T) - 1.5*IQR(Numeric_ENV2[,j], na.rm = T)|Numeric_ENV2[,j] > quantile(Numeric_ENV2[,j], probs=c(.75), na.rm = T) + 1.5*IQR(Numeric_ENV2[,j], na.rm = T), Numeric_ENV2$Site_Date_Number, "")), hjust = -0.05, size = 3)

  dotchart <- ggplot(data = Numeric_ENV2, aes(y = seq(Numeric_ENV2[,j]), x = Numeric_ENV2[,j], na.rm = T)) +
    geom_point(na.rm = T) +
    ylab("Ordre des données") +
    xlab("Valeur") +
    theme(plot.title = element_text(hjust = 0.5)) +
    ggtitle(paste("Distribution des valeurs observées de", colnames(Numeric_ENV2[j]))) +
    geom_text(aes(label = ifelse(Numeric_ENV2[,j] < quantile(Numeric_ENV2[,j], probs=c(.25), na.rm = T) - 1.5*IQR(Numeric_ENV2[,j], na.rm = T)|Numeric_ENV2[,j] > quantile(Numeric_ENV2[,j], probs=c(.75), na.rm = T) + 1.5*IQR(Numeric_ENV2[,j], na.rm = T), Numeric_ENV2$Site_Date_Number, "")), hjust = -0.05, nudge_y = 2, size = 3)
        
  grid.arrange(boxplot, dotchart, ncol = 2)
}

```

```{r, echo=FALSE, warning=FALSE}
#Identification of potential outliers - variables binaires

for (j in 2:(ncol(Binary_ENV2)-2)) {
  boxplot <- ggplot(data = Binary_ENV2, aes(x = "", y = Binary_ENV2[,j])) +
    geom_boxplot() +
    ylab("Valeur") +
    xlab("") +
    theme(plot.title = element_text(hjust = 0.5)) +
    ggtitle(paste("Valeurs observées de\n", colnames(Binary_ENV2[j]))) +
    geom_text(aes(label = ifelse(Binary_ENV2[,j] < quantile(Binary_ENV2[,j], probs=c(.25), na.rm = T) - 1.5*IQR(Binary_ENV2[,j], na.rm = T)|Binary_ENV2[,j] > quantile(Binary_ENV2[,j], probs=c(.75), na.rm = T) + 1.5*IQR(Binary_ENV2[,j], na.rm = T), Binary_ENV2$Site_Date_Number, "")), hjust = -0.05, size = 3)

  dotchart <- ggplot(data = Binary_ENV2, aes(y = seq(Binary_ENV2[,j]), x = Binary_ENV2[,j], na.rm = T)) +
    geom_point(na.rm = T) +
    ylab("Ordre des données") +
    xlab("Valeur") +
    theme(plot.title = element_text(hjust = 0.5)) +
    ggtitle(paste("Distribution des valeurs observées de", colnames(Binary_ENV2[j]))) +
    geom_text(aes(label = ifelse(Binary_ENV2[,j] < quantile(Binary_ENV2[,j], probs=c(.25), na.rm = T) - 1.5*IQR(Binary_ENV2[,j], na.rm = T)|Binary_ENV2[,j] > quantile(Binary_ENV2[,j], probs=c(.75), na.rm = T) + 1.5*IQR(Binary_ENV2[,j], na.rm = T), Binary_ENV2$Site_Date_Number, "")), hjust = -0.05, nudge_y = 2, size = 3)
        
  grid.arrange(boxplot, dotchart, ncol = 2)
}
```

```{r, echo=FALSE, warning=FALSE}
#Identification of potential outliers - autres variables

for (j in 2:(ncol(Other_ENV2 %>% dplyr::select(-Site_Date_Number)))) {
  boxplot <- ggplot(data = Other_ENV2, aes(x = "", y = Other_ENV2[,j])) +
    geom_boxplot() +
    ylab("Valeur") +
    xlab("") +
    theme(plot.title = element_text(hjust = 0.5)) +
    ggtitle(paste("Valeurs observées de\n", colnames(Other_ENV2[j]))) +
    geom_text(aes(label = ifelse(Other_ENV2[,j] < quantile(Other_ENV2[,j], probs=c(.25), na.rm = T) - 1.5*IQR(Other_ENV2[,j], na.rm = T)|Other_ENV2[,j] > quantile(Other_ENV2[,j], probs=c(.75), na.rm = T) + 1.5*IQR(Other_ENV2[,j], na.rm = T), Other_ENV2$Site_Date_Number, "")), hjust = -0.05, size = 3)

  dotchart <- ggplot(data = Other_ENV2, aes(y = seq(Other_ENV2[,j]), x = Other_ENV2[,j], na.rm = T)) +
    geom_point(na.rm = T) +
    ylab("Ordre des données") +
    xlab("Valeur") +
    theme(plot.title = element_text(hjust = 0.5)) +
    ggtitle(paste("Distribution des valeurs observées de", colnames(Other_ENV2[j]))) +
    geom_text(aes(label = ifelse(Other_ENV2[,j] < quantile(Other_ENV2[,j], probs=c(.25), na.rm = T) - 1.5*IQR(Other_ENV2[,j], na.rm = T)|Other_ENV2[,j] > quantile(Other_ENV2[,j], probs=c(.75), na.rm = T) + 1.5*IQR(Other_ENV2[,j], na.rm = T), Other_ENV2$Site_Date_Number, "")), hjust = -0.05, nudge_y = 2, size = 3)
        
  grid.arrange(boxplot, dotchart, ncol = 2)
}
```

La liste suivante présente une façon alternative d'identifier les données potentiellement aberrantes contenues dans le fichier de données pour chaque variable. Lorsque l'identifiant d'une donnée y est indiqué, cela indique que cette donnée représente une donnée potentiellement aberrante contenue dans le fichier de données. Les mentions *""* indiquent les données non aberrantes et les mentions *NA* indiquent la présence de valeurs manquantes. L'identifiant de la visite correspond au nom du site d'où provient la donnée, sa date d'échantillonnage et le nombre d'échantillonnage pris pour cette donnée.

```{r, echo=FALSE}
#Identification des données aberrantes potentielles (suite) - données numériques

for (j in 2:(ncol(Numeric_ENV2 %>% dplyr::select(-Site_Date_Number)))) {
  cat(colnames(Numeric_ENV2[j]), "\n")
  Active_Frame_Num_Env <- data.frame(ifelse(is.na(Numeric_ENV2[, j]), "", ifelse(Numeric_ENV2[, j] < quantile(Numeric_ENV2[, j], probs = c(.25), na.rm = T) - 1.5 * IQR(Numeric_ENV2[, j], na.rm = T) | Numeric_ENV2[, j] > quantile(Numeric_ENV2[, j], probs = c(.75), na.rm = T) + 1.5 * IQR(Numeric_ENV2[, j], na.rm = T), Numeric_ENV2$Site_Date_Number, "")))
  Active_Frame_Num_Env["Is NA"] <- list(ifelse(is.na(Numeric_ENV2[, j]), "Yes", "No"))
  colnames(Active_Frame_Num_Env) <- c("Site, Date and Number")
  write.table(Active_Frame_Num_Env[Active_Frame_Num_Env$"Site, Date and Number" != "", ], row.names = FALSE, quote = FALSE, na = "NA", sep = ", ")
  cat("Nombre de données aberrantes potentielles:", length(Active_Frame_Num_Env[Active_Frame_Num_Env$"Site, Date and Number" != "", ][[1]]), "\n\n")
}

```

```{r, echo=FALSE}
#Identification des données aberrantes potentielles (suite) - données binaires

for (j in 2:(ncol(Binary_ENV2 %>% dplyr::select(-Site_Date_Number)))) {
  cat(colnames(Binary_ENV2[j]), "\n")
  Active_Frame_Bin_Env <- data.frame(ifelse(is.na(Binary_ENV2[, j]), "", ifelse(Binary_ENV2[, j] < quantile(Binary_ENV2[, j], probs = c(.25), na.rm = T) - 1.5 * IQR(Binary_ENV2[, j], na.rm = T) | Binary_ENV2[, j] > quantile(Binary_ENV2[, j], probs = c(.75), na.rm = T) + 1.5 * IQR(Binary_ENV2[, j], na.rm = T), Binary_ENV2$Site_Date_Number, "")))
  Active_Frame_Bin_Env["Is NA"] <- list(ifelse(is.na(Binary_ENV2[, j]), "Yes", "No"))
  colnames(Active_Frame_Bin_Env) <- c("Site, Date and Number")
  write.table(Active_Frame_Bin_Env[Active_Frame_Bin_Env$"Site, Date and Number" != "", ], row.names = FALSE, quote = FALSE, na = "NA", sep = ", ")
  cat("Nombre de données aberrantes potentielles:", length(Active_Frame_Bin_Env[Active_Frame_Bin_Env$"Site, Date and Number" != "", ][[1]]), "\n\n")
}

```

```{r, echo=FALSE}
#Identification des données aberrantes potentielles (suite) - autres données

for (j in 2:(ncol(Other_ENV2 %>% dplyr::select(-Site_Date_Number)))) {
  cat(colnames(Other_ENV2[j]), "\n")
  Active_Frame_Other_Env <- data.frame(ifelse(is.na(Other_ENV2[, j]), "", ifelse(Other_ENV2[, j] < quantile(Other_ENV2[, j], probs = c(.25), na.rm = T) - 1.5 * IQR(Other_ENV2[, j], na.rm = T) | Other_ENV2[, j] > quantile(Other_ENV2[, j], probs = c(.75), na.rm = T) + 1.5 * IQR(Other_ENV2[, j], na.rm = T), Other_ENV2$Site_Date_Number, "")))
  Active_Frame_Other_Env["Is NA"] <- list(ifelse(is.na(Other_ENV2[, j]), "Yes", "No"))
  colnames(Active_Frame_Other_Env) <- c("Site, Date and Number")
  write.table(Active_Frame_Other_Env[Active_Frame_Other_Env$"Site, Date and Number" != "", ], row.names = FALSE, quote = FALSE, na = "NA", sep = ", ")
  cat("Nombre de données aberrantes potentielles:", length(Active_Frame_Other_Env[Active_Frame_Other_Env$"Site, Date and Number" != "", ][[1]]), "\n\n")
}

```

```{r, echo=FALSE, eval=FALSE}
#Identification des données aberrantes - variables numériques

for (j in 2:(ncol(Numeric_ENV2 %>% dplyr::select(-Site_Date_Number)))) {
  cat(colnames(Numeric_ENV2[j]), "\n")
  Active_Frame_Num_Env <- data.frame(ifelse(is.na(Numeric_ENV2[, j]), Numeric_ENV2$Site_Date_Number, ""))
  Active_Frame_Num_Env["Is NA"] <- list(ifelse(is.na(Numeric_ENV2[, j]), "Yes", "No"))
  colnames(Active_Frame_Num_Env) <- c("Site, Date and Number", "Is NA")
  write.table(Active_Frame_Num_Env[Active_Frame_Num_Env$"Site, Date and Number" != "", ], row.names = FALSE, quote = FALSE, na = "NA", sep = ", ")
  cat("Nombre de données aberrantes potentielles:", length(Active_Frame_Num_Env[Active_Frame_Num_Env$"Site, Date and Number" != "", ][[1]]), "\n\n")
}

```

```{r, echo=FALSE, eval=FALSE}
#Identification des données aberrantes - variables binaires

for (j in 2:(ncol(Binary_ENV2 %>% dplyr::select(-Site_Date_Number)))) {
  cat(colnames(Binary_ENV2[j]), "\n")
  Active_Frame_Bin_Env <- data.frame(ifelse(is.na(Binary_ENV2[, j]), Binary_ENV2$Site_Date_Number, ""))
  Active_Frame_Bin_Env["Is NA"] <- list(ifelse(is.na(Binary_ENV2[, j]), "Yes", "No"))
  colnames(Active_Frame_Bin_Env) <- c("Site, Date and Number", "Is NA")
  write.table(Active_Frame_Bin_Env[Active_Frame_Bin_Env$"Site, Date and Number" != "", ], row.names = FALSE, quote = FALSE, na = "NA", sep = ", ")
  cat("Nombre de données aberrantes potentielles:", length(Active_Frame_Bin_Env[Active_Frame_Bin_Env$"Site, Date and Number" != "", ][[1]]), "\n\n")
}

```

```{r, echo=FALSE, eval=FALSE}
#Identification des données aberrantes - autres variables

for (j in 2:(ncol(Other_ENV2 %>% dplyr::select(-Site_Date_Number)))) {
  cat(colnames(Other_ENV2[j]), "\n")
  Active_Frame_Other_Env <- data.frame(ifelse(is.na(Other_ENV2[, j]), Other_ENV2$Site_Date_Number, ""))
  Active_Frame_Other_Env["Is NA"] <- list(ifelse(is.na(Other_ENV2[, j]), "Yes", "No"))
  colnames(Active_Frame_Other_Env) <- c("Site, Date and Number", "Is NA")
  write.table(Active_Frame_Other_Env[Active_Frame_Other_Env$"Site, Date and Number" != "", ], row.names = FALSE, quote = FALSE, na = "NA", sep = ", ")
  cat("Nombre de données aberrantes potentielles:", length(Active_Frame_Other_Env[Active_Frame_Other_Env$"Site, Date and Number" != "", ][[1]]), "\n\n")
}

```


## Normalité des données 

### Diagrammes Quantile-Quantile et histogrammes de fréquences

Pour chaque variable, le premier graphique (à gauche) illustre la distribution observée des valeurs par variable par des points et la distribution normale théorique calculée à partir des paramètres de la distribution observée par une droite. Plus les valeurs observées sont positionnées sur la droite, plus celles-ci sont distribuées selon la loi normale.

Le deuxième graphique (au milieu) illustre par un histogramme la distribution des fréquences des valeurs observées par taxon. Cet histogramme illustre également la valeur moyenne par variable par une ligne pleine ainsi que l'écart-type des variables par deux lignes pointillées.

Le troisième graphique (à droite) illustre la distribution des fréquences des valeurs observées par variable ayant subies une transformation logarithmique. Si la distribution des données sur ce dernier graphique semble ressembler davantage à une distribution normale, une transformation logarithmique des données pourrait être nécessaire. Cet histogramme illustre également la valeur moyenne par variable par une ligne pleine ainsi que l'écart-type des variables par deux lignes pointillées.

```{r, echo=FALSE} 
#Diagrammes Quantile-Quantile et histogrammes de fréquences - variables numériques

 norm.bin <- vector(length=ncol(Numeric_ENV2))
 for (i in 2:ncol(Numeric_ENV2 %>% dplyr::select(-Site_Date_Number))){
 	norm.mean <- mean(Numeric_ENV2[,i], na.rm=T)
 	norm.sd <- sd(Numeric_ENV2[,i], na.rm=T)
 	norm.n <- length(which(!is.na(Numeric_ENV2[,i])))
 	norm.bin[i] <- ceiling((max(Numeric_ENV2[,i], na.rm=T) - min(Numeric_ENV2[,i],na.rm=T)) /nclass.Sturges(which(!is.na(Numeric_ENV2[,i]))))

 	if(norm.bin[i]>1){

 	par(mfrow = c(1,3), oma=c(1,1,2,1))

 	qqnorm(which(!is.na(Numeric_ENV2[,i])), main = "Diagramme Quantile-Quantile")
 	qqline(which(!is.na(Numeric_ENV2[,i])),lty = 2)

 	hist.ab <- hist(as.numeric(unlist(Numeric_ENV2[,i])), breaks = "Sturges", xlab = "Valeur", ylab = "Fréquence", main = "Distribution de fréquence")
 	xfit <- seq(min(which(!is.na(Numeric_ENV2[,i]))), max(which(!is.na(Numeric_ENV2[,i]))), length=norm.n)
 	yfit_density <- dnorm(xfit, mean = norm.mean, sd=norm.sd)
 	yfit_freq <- yfit_density*diff(hist.ab$mids[1:2])*norm.n
 	lines(xfit, yfit_freq, col="red", lwd=1)
   		abline(v = norm.mean, col = "blue") +
   		abline(v = norm.mean + norm.sd, lty = 2, col = "blue") +
   		abline(v = norm.mean - norm.sd, lty = 2, col = "blue")

 	norm.mean.log <- mean(log(which(!is.na(Numeric_ENV2[,i]))))
 	norm.sd.log <- sd(log(which(!is.na(Numeric_ENV2[,i]))))
 	norm.n.log <- length(log(which(!is.na(Numeric_ENV2[,i]))))
 	norm.bin.log <- ceiling(max(log(which(!is.na(Numeric_ENV2[,i]))))- min(log(which(!is.na(Numeric_ENV2[,i]))))/nclass.Sturges(log(which(!is.na(Numeric_ENV2[,i])))))

 	hist.ab.2 <- hist(log(as.numeric(unlist(Numeric_ENV2[,i]))), breaks = "Sturges", xlab = "Log(Valeur)", ylab = "Fréquence", main = "Distribution de fréquence (log)")
 	xfit <- seq(min(log(which(!is.na(Numeric_ENV2[,i])))), max(log(which(!is.na(Numeric_ENV2[,i])))), length=norm.n.log)
 	yfit_density <- dnorm(xfit, mean = norm.mean.log, sd=norm.sd.log)
 	yfit_freq <- yfit_density*diff(hist.ab.2$mids[1:2])*norm.n.log
 	lines(xfit, yfit_freq, col="red", lwd=1)
   		abline(v = norm.mean.log, col = "blue") +
   		abline(v = norm.mean.log + norm.sd.log, lty = 2, col = "blue") +
   		abline(v = norm.mean.log - norm.sd.log, lty = 2, col = "blue")
   	mtext(colnames(Numeric_ENV2[i]), cex = 1.2, outer = TRUE)}}
```

```{r, echo=FALSE} 
#Diagrammes Quantile-Quantile et histogrammes de fréquences - variables binaires 

 norm.bin <- vector(length=ncol(Binary_ENV2))
 for (i in 2:ncol(Binary_ENV2 %>% dplyr::select(-Site_Date_Number))){
 	norm.mean <- mean(Binary_ENV2[,i], na.rm=T)
 	norm.sd <- sd(Binary_ENV2[,i], na.rm=T)
 	norm.n <- length(which(!is.na(Binary_ENV2[,i])))
 	norm.bin[i] <- ceiling((max(Binary_ENV2[,i], na.rm=T) - min(Binary_ENV2[,i],na.rm=T)) /nclass.Sturges(which(!is.na(Binary_ENV2[,i]))))

 	if(norm.bin[i]>1){

 	par(mfrow = c(1,3), oma=c(1,1,2,1))

 	qqnorm(which(!is.na(Binary_ENV2[,i])), main = "Diagramme Quantile-Quantile")
 	qqline(which(!is.na(Binary_ENV2[,i])),lty = 2)

 	hist.ab <- hist(as.numeric(unlist(Binary_ENV2[,i])), breaks = "Sturges", xlab = "Valeur", ylab = "Fréquence", main = "Distribution de fréquence")
 	xfit <- seq(min(which(!is.na(Binary_ENV2[,i]))), max(which(!is.na(Binary_ENV2[,i]))), length=norm.n)
 	yfit_density <- dnorm(xfit, mean = norm.mean, sd=norm.sd)
 	yfit_freq <- yfit_density*diff(hist.ab$mids[1:2])*norm.n
 	lines(xfit, yfit_freq, col="red", lwd=1)
   		abline(v = norm.mean, col = "blue") +
   		abline(v = norm.mean + norm.sd, lty = 2, col = "blue") +
   		abline(v = norm.mean - norm.sd, lty = 2, col = "blue")

 	norm.mean.log <- mean(log(which(!is.na(Binary_ENV2[,i]))))
 	norm.sd.log <- sd(log(which(!is.na(Binary_ENV2[,i]))))
 	norm.n.log <- length(log(which(!is.na(Binary_ENV2[,i]))))
 	norm.bin.log <- ceiling(max(log(which(!is.na(Binary_ENV2[,i]))))- min(log(which(!is.na(Binary_ENV2[,i]))))/nclass.Sturges(log(which(!is.na(Binary_ENV2[,i])))))

 	hist.ab.2 <- hist(log(as.numeric(unlist(Binary_ENV2[,i]))), breaks = "Sturges", xlab = "Log(Valeur)", ylab = "Fréquence", main = "Distribution de fréquence (log)")
 	xfit <- seq(min(log(which(!is.na(Binary_ENV2[,i])))), max(log(which(!is.na(Binary_ENV2[,i])))), length=norm.n.log)
 	yfit_density <- dnorm(xfit, mean = norm.mean.log, sd=norm.sd.log)
 	yfit_freq <- yfit_density*diff(hist.ab.2$mids[1:2])*norm.n.log
 	lines(xfit, yfit_freq, col="red", lwd=1)
   		abline(v = norm.mean.log, col = "blue") +
   		abline(v = norm.mean.log + norm.sd.log, lty = 2, col = "blue") +
   		abline(v = norm.mean.log - norm.sd.log, lty = 2, col = "blue")
   	mtext(colnames(Binary_ENV2[i]), cex = 1.2, outer = TRUE)}}
```

```{r, echo=FALSE} 
#Diagrammes Quantile-Quantile et histogrammes de fréquences - autres variables

 norm.bin <- vector(length=ncol(Other_ENV2))
 for (i in 2:ncol(Other_ENV2 %>% dplyr::select(-Site_Date_Number))){
 	norm.mean <- mean(Other_ENV2[,i], na.rm=T)
 	norm.sd <- sd(Other_ENV2[,i], na.rm=T)
 	norm.n <- length(which(!is.na(Other_ENV2[,i])))
 	norm.bin[i] <- ceiling((max(Other_ENV2[,i], na.rm=T) - min(Other_ENV2[,i],na.rm=T)) /nclass.Sturges(which(!is.na(Other_ENV2[,i]))))

 	if(norm.bin[i]>1){

 	par(mfrow = c(1,3), oma=c(1,1,2,1))

 	qqnorm(which(!is.na(Other_ENV2[,i])), main = "Diagramme Quantile-Quantile")
 	qqline(which(!is.na(Other_ENV2[,i])),lty = 2)

 	hist.ab <- hist(as.numeric(unlist(Other_ENV2[,i])), breaks = "Sturges", xlab = "Valeur", ylab = "Fréquence", main = "Distribution de fréquence")
 	xfit <- seq(min(which(!is.na(Other_ENV2[,i]))), max(which(!is.na(Other_ENV2[,i]))), length=norm.n)
 	yfit_density <- dnorm(xfit, mean = norm.mean, sd=norm.sd)
 	yfit_freq <- yfit_density*diff(hist.ab$mids[1:2])*norm.n
 	lines(xfit, yfit_freq, col="red", lwd=1)
   		abline(v = norm.mean, col = "blue") +
   		abline(v = norm.mean + norm.sd, lty = 2, col = "blue") +
   		abline(v = norm.mean - norm.sd, lty = 2, col = "blue")

 	norm.mean.log <- mean(log(which(!is.na(Other_ENV2[,i]))))
 	norm.sd.log <- sd(log(which(!is.na(Other_ENV2[,i]))))
 	norm.n.log <- length(log(which(!is.na(Other_ENV2[,i]))))
 	norm.bin.log <- ceiling(max(log(which(!is.na(Other_ENV2[,i]))))- min(log(which(!is.na(Other_ENV2[,i]))))/nclass.Sturges(log(which(!is.na(Other_ENV2[,i])))))

 	hist.ab.2 <- hist(log(as.numeric(unlist(Other_ENV2[,i]))), breaks = "Sturges", xlab = "Log(Valeur)", ylab = "Fréquence", main = "Distribution de fréquence (log)")
 	xfit <- seq(min(log(which(!is.na(Other_ENV2[,i])))), max(log(which(!is.na(Other_ENV2[,i])))), length=norm.n.log)
 	yfit_density <- dnorm(xfit, mean = norm.mean.log, sd=norm.sd.log)
 	yfit_freq <- yfit_density*diff(hist.ab.2$mids[1:2])*norm.n.log
 	lines(xfit, yfit_freq, col="red", lwd=1)
   		abline(v = norm.mean.log, col = "blue") +
   		abline(v = norm.mean.log + norm.sd.log, lty = 2, col = "blue") +
   		abline(v = norm.mean.log - norm.sd.log, lty = 2, col = "blue")
   	mtext(colnames(Other_ENV2[i]), cex = 1.2, outer = TRUE)

   }
 }
```


*Ancien diagramme à supprimer*

```{r, echo=FALSE}
#Diagrammes Quantile-Quantile et histogrammes de fréquences

## PEUT-ETRE LES ÉTIQUETTES CORRECTS POUR LES AXES 

for (i in 1:ncol(dataset.ENV)){
	norm.mean <- mean(which(!is.na(dataset.ENV[,i])))
	norm.sd <- sd(which(!is.na(dataset.ENV[,i])))
	norm.n <- length(which(!is.na(dataset.ENV[,i])))
	norm.bin <- ceiling(max(which(!is.na(dataset.ENV[,i])))- min(which(!is.na(dataset.ENV[,i])))/nclass.Sturges(which(!is.na(dataset.ENV[,i]))))

	par(mfrow = c(1,3), oma=c(1,1,2,1))

	qqnorm(which(!is.na(dataset.ENV[,i])), main = "Diagramme Quantile-Quantile (À SUPPRIMER)", xlab = "Quantiles de la loi normale", ylab = "Quantiles normalisés observés")
	qqline(which(!is.na(dataset.ENV[,i])),lty = 2)

	hist.ab <- hist(as.numeric(unlist(dataset.ENV[,i])), breaks = "Sturges", xlab = "Valeur", ylab = "Fréquence", main = "Fréquences d'abondances")
	xfit <- seq(min(which(!is.na(dataset.ENV[,i]))), max(which(!is.na(dataset.ENV[,i]))), length=norm.n)
	yfit_density <- dnorm(xfit, mean = norm.mean, sd=norm.sd)
	yfit_freq <- yfit_density*diff(hist.ab$mids[1:2])*norm.n
	lines(xfit, yfit_freq, col="red", lwd=1)
	  abline(v = norm.mean, col = "blue") +
	  abline(v = norm.mean + norm.sd, lty = 2, col = "blue") +
	  abline(v = norm.mean - norm.sd, lty = 2, col = "blue")

	norm.mean.log <- mean(log(which(!is.na(dataset.ENV[,i]))))
	norm.sd.log <- sd(log(which(!is.na(dataset.ENV[,i]))))
	norm.n.log <- length(log(which(!is.na(dataset.ENV[,i]))))
	norm.bin.log <- ceiling(max(log(which(!is.na(dataset.ENV[,i]))))- min(log(which(!is.na(dataset.ENV[,i]))))/nclass.Sturges(log(which(!is.na(dataset.ENV[,i])))))
  
	hist.ab.2 <- hist(log(as.numeric(unlist(dataset.ENV[,i]))), breaks = "Sturges", xlab = "Log(Abondance)", ylab = "Fréquence", main = "Fréquences d'abondances (log)")
	xfit <- seq(min(log(which(!is.na(dataset.ENV[,i])))), max(log(which(!is.na(dataset.ENV[,i])))), length=norm.n.log)
	yfit_density <- dnorm(xfit, mean = norm.mean.log, sd=norm.sd.log)
	yfit_freq <- yfit_density*diff(hist.ab.2$mids[1:2])*norm.n.log
	lines(xfit, yfit_freq, col="red", lwd=1)
	  abline(v = norm.mean.log, col = "blue") +
	  abline(v = norm.mean.log + norm.sd.log, lty = 2, col = "blue") +
	  abline(v = norm.mean.log - norm.sd.log, lty = 2, col = "blue")
	mtext(colnames(dataset.ENV[i]), cex = 1.2, outer = TRUE)

  }

```


###Boîtes à moustaches des valeurs observées par variable environnementale

Pour chaque variable, la première boîte à moustaches (à gauche) illustre la distribution des valeurs observées dans le fichier de données et la deuxième boîte à moustaches (à droite) illustre la distribution des valeurs observées dans le fichier de données ayant subies une transformation logarithmique.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#Boîtes à moustaches des valeurs observées par variable numérique d'habitat

for(i in 2:ncol(Numeric_ENV2 %>% dplyr::select(-Site_Date_Number))){
box.ab.1 <- qplot(y = Numeric_ENV2[,i], x = "", geom = "boxplot", ylab = "Valeur") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("Données brutes"))
box.ab.2 <- qplot(y = Numeric_ENV2[,i], x = "", geom = "boxplot", ylab = "Log(Valeur)", log = "y") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("log(données brutes)"))

grid.arrange(box.ab.1, box.ab.2, ncol = 2, top = colnames(Numeric_ENV2[i]))}
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#Boîtes à moustaches des valeurs observées par variable binaire d'habitat

for(i in 2:ncol(Binary_ENV2 %>% dplyr::select(-Site_Date_Number))){
box.ab.1 <- qplot(y = Binary_ENV2[,i], x = "", geom = "boxplot", ylab = "Valeur") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("Données brutes"))
box.ab.2 <- qplot(y = Binary_ENV2[,i], x = "", geom = "boxplot", ylab = "Log(Valeur)", log = "y") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("Log(données brutes)"))

grid.arrange(box.ab.1, box.ab.2, ncol = 2, top = colnames(Binary_ENV2[i]))}
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#Boîtes à moustaches des valeurs observées par autre variable d'habitat

for(i in 1:ncol(Other_ENV2 %>% dplyr::select(-Site_Date_Number))){
box.ab.1 <- qplot(y = Other_ENV2[,i], x = "", geom = "boxplot", ylab = "Valeur") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("Données brutes"))
box.ab.2 <- qplot(y = Other_ENV2[,i], x = "", geom = "boxplot", ylab = "Log(Valeur)", log = "y") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste("Log(données brutes)"))

grid.arrange(box.ab.1, box.ab.2, ncol = 2, top = colnames(Other_ENV2[i]))}
```


### Tests de normalité

Les résultats suivants présentent le résultat obtenu par un test de Snows appliqué sur chaque variable du fichier de données. Une valeur de P (p-value) inférieure à 0.05 indique qu'il n'est pas possible de supposer que la distribution des données suit la loi normale avec une probabilité de 95%. 

```{r, echo=FALSE, warning=FALSE}
#Tests de normalité de Snows par variable

apply(Numeric_ENV2, 2, SnowsPenultimateNormalityTest)
apply(Binary_ENV2, 2, SnowsPenultimateNormalityTest)
apply(Other_ENV2, 2, SnowsPenultimateNormalityTest)


#Une valeur de P (p-value) inférieure à 0.05 indique qu'il n'est pas possible de considérer que les données suivent une distribution normale. 

```


## Collinéarité des variables

### Matrice de diagrammes de disperson

La matrice de diagrammes de dispersion suivante illustre la relation qui existe entre des pairs de variables. Elle permet notamment de détecter la présence de corrélations entre des variables.

```{r, echo=FALSE}
#Matrice de corrélation entre les variables numériques

Numeric_ENV2_bk <- Numeric_ENV2
Numeric_ENV2[is.na(Numeric_ENV2)] <- 0
Numeric_ENV2$SampleId <- NULL
Numeric_ENV2$Site_Date_Number <- NULL

ifelse(ncol(Numeric_ENV2)>=20, numb_scatter <- 20, numb_scatter <-ncol(Numeric_ENV2))

GGally::ggpairs(Numeric_ENV2[,1:numb_scatter])

for(i in 1:ceiling(length(Numeric_ENV2[,1:numb_scatter])/4)){for(j in 1:ceiling(length(Numeric_ENV2[,1:numb_scatter])/4)){print(ggduo(Numeric_ENV2[,1:numb_scatter], columnsX=((i*4-3):(i*4))[((i*4-3):(i*4))<=length(Numeric_ENV2[,1:numb_scatter])], columnsY=((j*4-3):(j*4))[((j*4-3):(j*4))<=length(Numeric_ENV2[,1:numb_scatter])]))}}

Numeric_ENV2 <- Numeric_ENV2_bk
```

```{r, echo=FALSE}
#Matrice de corrélation entre les variables binaires

Binary_ENV2_bk <- Binary_ENV2
Binary_ENV2[is.na(Binary_ENV2)] <- 0
Binary_ENV2$SampleId <- NULL
Binary_ENV2$Site_Date_Number <- NULL

ifelse(ncol(Binary_ENV2)>=20, numb_scatter <- 20, numb_scatter <-ncol(Binary_ENV2))

GGally::ggpairs(Binary_ENV2[,1:numb_scatter])

for(i in 1:ceiling(length(Binary_ENV2[,1:numb_scatter])/4)){for(j in 1:ceiling(length(Binary_ENV2[,1:numb_scatter])/4)){print(ggduo(Binary_ENV2[,1:numb_scatter], columnsX=((i*4-3):(i*4))[((i*4-3):(i*4))<=length(Binary_ENV2[,1:numb_scatter])], columnsY=((j*4-3):(j*4))[((j*4-3):(j*4))<=length(Binary_ENV2[,1:numb_scatter])]))}}

Binary_ENV2 <- Binary_ENV2_bk
```

```{r, echo=FALSE}
#Matrice de corrélation entre les autres variables

Other_ENV2_bk <- Other_ENV2
Other_ENV2[is.na(Other_ENV2)] <- 0
Other_ENV2$SampleId <- NULL
Other_ENV2$Site_Date_Number <- NULL

ifelse(ncol(Other_ENV2)>=20, numb_scatter <- 20, numb_scatter <-ncol(Other_ENV2))
GGally::ggpairs(Other_ENV2[,1:numb_scatter])

for(i in 1:ceiling(length(Other_ENV2[,1:numb_scatter])/4)){for(j in 1:ceiling(length(Other_ENV2[,1:numb_scatter])/4)){print(ggduo(Other_ENV2[,1:numb_scatter], columnsX=((i*4-3):(i*4))[((i*4-3):(i*4))<=length(Other_ENV2[,1:numb_scatter])], columnsY=((j*4-3):(j*4))[((j*4-3):(j*4))<=length(Other_ENV2[,1:numb_scatter])]))}}

Other_ENV2 <- Other_ENV2_bk

```



*À retravailler au besoin*

```{r, echo=FALSE}
#Matrice de corrélation entre les variables

# À RETRAVAILLER POUR INCLURE TOUTES LES VARIABLES

dataset.ENV[is.na(dataset.ENV)] <- 0

AllS <- names(dataset.ENV)
Env <- dataset.ENV[,AllS]

PlotMatrix(Env, panel = panel.smooth)

dataset.ENV[dataset.ENV == 0] <- NA

```


### Indépendance temporelle des variables

Pour chaque variable, le premier graphique (en haut à gauche) illustre la valeur observée des données selon leur année d'échantillonnage. Le deuxième graphique (en haut à droite) illustre les tendances observées de variations des valeurs des données dans le temps. Le troisième graphique (en bas à gauche) illustre les prévisions futures de variations des valeurs dans le temps. Sur ce graphique la ligne bleue correspond à la tendance attendue moyenne de variations dans le temps, la zone grise foncée correspond à un intervalle de confiance de 80% et la zone grise pâle correspond à un intervalle de confiance de 95%. Le quatrième graphique (en bas à droite) illustre l'autocorrélation de séries temporelles (ACF). Une valeur d'autocorrélation  supérieure à l'intervalle de confiance de 95% illustrée par la ligne pointillée indique une possible dépendance entre la variable et la période de l'année (temps). Par exemple, une certaine valeur d'une variable observée lors d'une année précise pourrait être expliquée par un certain événement datant d'une année antérieure (décalage dans le temps en années). Il est à noter que l'autocorrélation au temps de décalage 0 est, par définition, égale à 1.

```{r, echo=FALSE}
#Indépendance temporelle des variables numérique

dataset.ENV2 <- left_join(dataset.ENV2, dataset.NAM2[,c("SampleId", "SampleDate")], by = "SampleId")

Numeric_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude))[,which(Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]=="Numeric" | colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)) %in% c("SampleId", "SampleDate"))]

Numeric_ENV2_bk <- Numeric_ENV2
Numeric_ENV2[is.na(Numeric_ENV2)] <- 0

for(i in 2:(ncol(Numeric_ENV2)-2)){
  par(mfrow = c(2, 2), mar = c(1,1,2,1))
  graph.time <- plot(Numeric_ENV2$SampleDate, Numeric_ENV2[,i], xlab = "Année", ylab = "Valeur", main = "Valeurs observées")

  graph.time2 <- ts(Numeric_ENV2[,i], frequency = 12, start = c(2005-01-01), end = c(2016-01-01))
  plot(graph.time2, xlab = "Année", ylab = "Valeur", main = "Valeurs prédites")

  auto.arima <- auto.arima(graph.time2)
  graph.auto.arima <- plot(forecast(auto.arima, h = 120), main = "Prévision (ARIMA)")
  
  graph.lag <- acf(graph.time2, xlab = "Décalage (année)", ylab = "ACF", main = "Fonction d'autocorrélation", ylim = c(0, 1))
}

Numeric_ENV2 <- Numeric_ENV2_bk
 
#rm(dataset.NAM2)

```

```{r, echo=FALSE}
#Indépendance temporelle des variables binaires

Binary_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude))[,which(Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]=="Binary" | colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)) %in% c("SampleId", "SampleDate"))]

Binary_ENV2_bk <- Binary_ENV2
Binary_ENV2[is.na(Binary_ENV2)] <- 0

for(i in 2:(ncol(Binary_ENV2)-2)){
  par(mfrow = c(2, 2), mar = c(1,1,2,1))
  graph.time <- plot(Binary_ENV2$SampleDate, Binary_ENV2[,i], xlab = "Year", ylab = "Valeur", main = "Valeurs observées")

  graph.time2 <- ts(Binary_ENV2[,i], frequency = 12, start = c(2005-01-01), end = c(2016-01-01))
  plot(graph.time2, xlab = "Année", ylab = "Valeur", main = "Valeurs prédites")

  auto.arima <- auto.arima(graph.time2)
  graph.auto.arima <- plot(forecast(auto.arima, h = 120), main = "Prévision (ARIMA)")
  
  graph.lag <- acf(graph.time2, xlab = "Décalage (année)", ylab = "ACF", main = "Fonction d'autocorrélation", ylim = c(0, 1))
}

Binary_ENV2 <- Binary_ENV2_bk
```

```{r, echo=FALSE}
#Indépendance temporelle des autres variables

Other_ENV2 <- (dplyr::select(dataset.ENV2, -Longitude, -Latitude))[,which((Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]!="Numeric" & Var_Type[match(colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)), Var_Type[,1]),2]!="Binary") | colnames(dataset.ENV2 %>% dplyr::select(-Longitude, -Latitude)) %in% c("SampleId", "SampleDate"))]

Other_ENV2_bk <- Other_ENV2
Other_ENV2[is.na(Other_ENV2)] <- 0

for(i in 2:(ncol(Other_ENV2)-2)){
  par(mfrow = c(2, 2), mar = c(1,1,2,1))
  graph.time <- plot(Other_ENV2$SampleDate, Other_ENV2[,i], xlab = "Année", ylab = "Valeur", main = "Valeurs observées")

  graph.time2 <- ts(Other_ENV2[,i], frequency = 12, start = c(2005-01-01), end = c(2016-01-01))
  plot(graph.time2, xlab = "Année", ylab = "Valeur", main = "Valeurs prédites")

  auto.arima <- auto.arima(graph.time2)
  graph.auto.arima <- plot(forecast(auto.arima, h = 120), main = "Prévision (ARIMA)")
  
  graph.lag <- acf(graph.time2, xlab = "Décalage (année)", ylab = "ACF", main = "Fonction d'autocorrélation", ylim = c(0, 1))
}

Other_ENV2 <- Other_ENV2_bk
```


Plus bas se trouvent les résultats du test de la statistique de Ljung–Box appliqué sur chaque variable et confirment les résultats illustrés par les graphiques précédents. Une valeur de P (p-value) inférieure à 0.05 permet de supposer que les valeurs résiduelles d'une variable dépendent de la période de l'année (temps).

```{r, echo=FALSE}
#Indépendance temporelle des variables numériques (suite)

Numeric_ENV2[is.na(Numeric_ENV2)] <- 0

for(i in 2:(ncol(Numeric_ENV2)-2)){
  graph.time2 <- ts(Numeric_ENV2[,i], frequency = 12, start = c(2005-01-01), end = c(2016-01-01))
  auto.arima <- auto.arima(graph.time2)
  box <- lapply(1:20, function(j) Box.test (resid(auto.arima), lag = j, type="Ljung"))
  print(paste(colnames(Numeric_ENV2[i])))  
  print(box)}

Numeric_ENV2 <- Numeric_ENV2_bk
```

```{r, echo=FALSE}
#Indépendance temporelle des variables binaires (suite)

Binary_ENV2[is.na(Binary_ENV2)] <- 0

for(i in 2:(ncol(Binary_ENV2)-2)){
  graph.time2 <- ts(Binary_ENV2[,i], frequency = 12, start = c(2005-01-01), end = c(2016-01-01))
  auto.arima <- auto.arima(graph.time2)
  box <- lapply(1:20, function(j) Box.test (resid(auto.arima), lag = j, type="Ljung"))
  print(paste(colnames(Binary_ENV2[i])))  
  print(box)
}

Binary_ENV2 <- Binary_ENV2_bk
```

```{r, echo=FALSE}
#Indépendance temporelle des autres variables (suite)

Other_ENV2[is.na(Other_ENV2)] <- 0

for(i in 2:(ncol(Other_ENV2)-2)){
  graph.time2 <- ts(Other_ENV2[,i], frequency = 12, start = c(2005-01-01), end = c(2016-01-01))
  auto.arima <- auto.arima(graph.time2)
  box <- lapply(1:20, function(j) Box.test (resid(auto.arima), lag = j, type="Ljung"))
  print(paste(colnames(Other_ENV2[i])))  
  print(box)}

Other_ENV2 <- Other_ENV2_bk
```


##Notes sur les versions
**Quoi de nouveau, mis à jour ou corrigé dans cette version**

***
![ACTION:](../../../Configuration/logo_new.png) Nouveau &nbsp;&nbsp;&nbsp;   ![ACTION:](../../../Configuration/logo_updated.png) Mise à jour &nbsp;&nbsp;&nbsp;  ![ACTION:](../../../Configuration/logo_fixed.png) Corrigé

***

**RCBA_vv_habitat.Rmd Version 1.1 — 1er novembre 2017**

Cette version présente des suggestions d'actions en rapport avec la vérification et validation des données générales.

![ACTION:](../../../Configuration/logo_new.png)   **Actions**.

**RCBA_vv_habitat.Rmd Version 1.0 — 18 août 2017**

Version initiale de l'outil de vérification et validation des données d'habitat.

![ACTION:](../../../Configuration/logo_new.png)   **Première version**.


***

Développé par [Martin Jean](mailto:martin.jean@canada.ca), Evelyne Paquette-Boisclair, et Eva Charbonneau-Bérubé
